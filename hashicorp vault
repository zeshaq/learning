HashiCorp Vault


1. Core Purpose

ğŸ” Secrets Management

Securely store API keys, passwords, tokens, and certificates

ğŸ§  Dynamic Secrets

Generate credentials on demand (e.g., database, AWS IAM)

ğŸ” Encryption as a Service

Centralized data encryption/decryption via API

ğŸ•µï¸â€â™‚ï¸ Access Control & Auditing

Enforce least-privilege access and maintain audit trails

2. Architecture Overview
ğŸ§± Components

Vault Server

Core service handling API requests and secret operations

Storage Backend

Persists encrypted data (e.g., Consul, Raft, DynamoDB, etcd)

Seal/Unseal Mechanism

Vault sealed on startup; requires unseal keys (Shamirâ€™s Secret Sharing)

Barrier Encryption

All stored data is encrypted before writing to backend

ğŸ”— Communication

API-driven

JSON REST APIs for apps and tools

TLS

Mandatory encryption in transit

3. Secret Engines
ğŸ§° Static Secrets

Key/Value (KV)

Basic secret storage engine

Supports versioning (KV v2)

âš™ï¸ Dynamic Secrets

Database Engine

On-demand DB credentials (MySQL, PostgreSQL, MongoDB, etc.)

AWS / Azure / GCP Engine

Temporary cloud credentials with TTL

PKI Engine

Generate short-lived X.509 certificates

SSH Engine

Dynamic SSH key signing

RabbitMQ / MongoDB / Cassandra / Kafka

Ephemeral credentials for service access

ğŸ” Encryption Engine

Transit Engine

Perform encrypt/decrypt/sign operations without storing data

Enables â€œencryption as a serviceâ€ model

4. Authentication Methods
ğŸ‘¤ Identity Providers

Userpass â€” basic user login

LDAP / Active Directory â€” enterprise directory integration

OIDC / OAuth / Okta â€” SSO integration

GitHub / GitLab / JWT â€” CI/CD and app authentication

Kubernetes Auth

Authenticate workloads using service account tokens

AppRole

For automated access by applications or machines

5. Access Control
ğŸ§© Policy System

Written in HCL (HashiCorp Configuration Language) or JSON

Define ACL policies to restrict access

Policies bound to identities, groups, or roles

ğŸ§  Namespaces (Enterprise Feature)

Multi-tenancy for large organizations

6. High Availability & Scalability
ğŸ—ï¸ HA Backends

Integrated Storage (Raft) â€” built-in and cluster-aware

Consul â€” distributed storage and leader election

DynamoDB / etcd â€” cloud-native backends

ğŸ”„ Auto-Unseal

Uses HSM, AWS KMS, or Google KMS for automated startup

Avoids manual unseal key entry

7. Audit Logging

Logs all API requests and responses

Supports file-based, socket-based, and syslog outputs

Can forward to SIEM tools (Splunk, ELK, etc.)

8. Integrations & Ecosystem
â˜¸ï¸ Kubernetes

Vault Agent Injector

Automatically injects secrets into pods

Vault CSI Driver

Mount secrets as volumes

Sidecar authentication with Kubernetes Auth method

ğŸ§± DevOps & CI/CD

Jenkins, GitLab CI, GitHub Actions integration

Terraform provider for Vault

ArgoCD + Vault for secure GitOps secrets

â˜ï¸ Cloud Integration

AWS IAM Auth + Dynamic AWS credentials

Azure MSI & GCP IAM integration

9. Security Features

Sealed by default

Shamirâ€™s Secret Sharing (threshold unseal keys)

Audit logs for all access

Short-lived credentials (TTL-based)

Encryption key rotation support

10. Popular Use Cases

ğŸ” Centralized secrets for microservices and CI/CD

â˜¸ï¸ Secure Kubernetes workloads (via Vault Agent)

ğŸ§© Database credential rotation

â˜ï¸ Cloud access with ephemeral credentials

ğŸ§  Application-level encryption (Transit engine)

ğŸ§¾ Certificate management with PKI engine

11. Alternatives / Complementary Tools

CyberArk Conjur â€” enterprise-grade secrets management

AWS Secrets Manager / Parameter Store â€” cloud-native

Azure Key Vault / GCP Secret Manager

Sealed Secrets / External Secrets Operator â€” for Kubernetes